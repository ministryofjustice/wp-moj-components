<?php
/**
 * Created by PhpStorm.
 * User: damienwilson
 * Date: 2019-09-27
 * Time: 10:22
 */

namespace component\Security;

use component\Security\VulnerabilityDBSettings as Settings;
use component\Versions\Plugins as Plugins;

class VulnerabilityDB
{
    /**
     * @var object
     */
    public $helper = '';

    /**
     * @var string
     */
    public $parentPath = '';

    /**
     * @var boolean
     */
    public $isOnS3;

    /**
     * holds the safe-name of an asset we are currently checking
     * @var string
     */
    public $assetName;

    /**
     * contains the version of an asset we are currently checking
     * @var string
     */
    public $version;

    /**
     * @var string
     */
    public $serviceUrl = "https://wpvulndb.com/api/v3/";

    /**
     * @var string
     */
    public $serviceToken = null;

    /**
     * @var array
     */
    public $pluginStatuses = null;

    /**
     * @var boolean
     */
    public $hasSettings = true;

    /**
     * @var object
     */
    public $settings = true;

    /**
     * @var object
     */
    public $forceVDBCheck = false;

    /**
     * @var bool
     */
    public $doingProcess = false;

    public function __construct()
    {
        global $mojHelper;
        $this->helper = $mojHelper;

        $this->settings = new Settings();

        $this->actions();
    }

    public function actions()
    {
        add_action('moj_check_vulnerabilities', [$this, 'process']);
        add_action('wp', [$this, 'schedule'], 10);

        // init the settings
        add_action('wp_loaded', [$this->settings, 'settings'], 1);
    }

    public function schedule()
    {
        if (!wp_next_scheduled('moj_check_vulnerabilities')) {
            wp_schedule_event(time(), 'daily', 'moj_check_vulnerabilities');

            return true;
        }

        // force check
        $options = get_option('moj_component_settings', '');
        if (isset($options['force_collect']) && $options['force_collect'] == 'yes') {
            wp_clear_scheduled_hook('moj_check_vulnerabilities');
            wp_schedule_single_event(time(), 'moj_check_vulnerabilities');

            $this->forceVDBCheck = true;
        }
    }

    /**
     * @SuppressWarnings(PHPMD.CamelCaseVariableName)
     * @return boolean
     */
    public function process()
    {
        global $wp_version;

        // don't allow multiple consecutive runs
        if ($this->doingProcess === true) {
            return false;
        }

        // TODO
        // untested
        $this->doingProcess = true;

        // do we have an API key?
        $settings = get_option('moj_component_settings');
        if (!isset($settings['vulndb_token']) || empty($settings['vulndb_token'])) {
            return false;
        }

        // if needed.. reset force check
        if ($this->forceVDBCheck) {
            $settings['force_collect'] = null;
            update_option('moj_component_settings', $settings);
        }

        // get local status cache
        //delete_option('moj_current_vuln_statuses');
        $localVulnStatuses = get_option('moj_current_vuln_statuses', array());

        $plugins = new Plugins();
        $pluginVersions = $plugins->get();
        $statuses = [];

        $this->pluginStatuses = [];
        if ($pluginVersions) {
            foreach ($pluginVersions as $plugin => $version) {
                if ($this->assetHasError($localVulnStatuses, $plugin) === false) {
                    $statuses[$plugin]['version'] = $version;
                    $statuses[$plugin]['status'] = $this->getData('plugins/' . $plugin);
                } else {
                    // manage a maximum count before we try again
                    $localVulnStatuses[$plugin]['counter'] = $localVulnStatuses[$plugin]['counter'] ?? 0;
                    $localVulnStatuses[$plugin]['counter']++;
                }
            }
        }

        $statuses['wordpress']['version'] = $wp_version;
        $statuses['wordpress']['status'] = $this->getData('wordpresses/', $wp_version);

        if (!empty($localVulnStatuses)) {
            // set aged
            $localVulnStatuses['aged'] = $localVulnStatuses['aged'] ?? 0;
            $localVulnStatuses['aged']++;

            // cache result
            update_option('moj_current_vuln_statuses', $localVulnStatuses);
        }

        // cache the entire result, if empty or aged
        if (empty($localVulnStatuses) || isset($localVulnStatuses['aged']) && $localVulnStatuses['aged'] > 10) {
            update_option('moj_current_vuln_statuses', $statuses);

            // if this was first run, prevent further execution and run the process again tomorrow
            if (empty($localVulnStatuses)) {
                return false;
            }
        }

        $result = $this->check($statuses);

        // notify if vulnerabilities were found
        if (!empty($result)) {
            $this->notify($result);
            return true;
        }
    }

    /**
     * @param $asset
     * @param $key
     * @return bool
     */
    private function assetHasError($asset, $key)
    {
        if (!isset($asset[$key])) {
            return false;
        }

        if (is_array($asset[$key]['status'])) {
            $error = $asset[$key]['status']['error'] ?? null;
        }

        $pluginDoesNotExist = false;
        if (isset($error) && $error !== 'Retry later') {
            $pluginDoesNotExist = true;

            // if counter is more than 5 let's check it again
            if (isset($asset[$key]['counter']) && $asset[$key]['counter'] > 1009) {
                $pluginDoesNotExist = false;
            }
        }

        if (isset($error) && $error === 'Retry later') {
            $pluginDoesNotExist = 'API blocked';
        }

        return $pluginDoesNotExist;
    }

    /**
     * @param $path | the endpoint of the request. Should contain plugins|themes|wordpresses
     * @param string $version
     * @return array
     */
    private function getData($path, $version = '')
    {
        $theUrl = $this->serviceUrl . $path . str_replace('.', '', $version);

        $response = wp_remote_retrieve_body(wp_remote_get(
            $theUrl,
            $this->requestHeaders()
        ));

        $data = (array)json_decode($response);

        if ($data && !key_exists('error', $data)) {
            if ($path === 'wordpresses/') {
                return $data[$version];
            }

            return $data[trim(strstr($path, '/'), '/')];
        }

        return $data;
    }

    public function requestHeaders()
    {
        $options = get_option('moj_component_settings');
        return [
            'headers' => [
                'Authorization' => 'Token token=' . $options['vulndb_token']
            ]
        ];
    }

    /**
     * @param $statuses
     * @return array
     */
    public function check($statuses)
    {
        $detected = [];

        foreach ($statuses as $scope => $plugin) {
            $status = (array)$plugin['status'];
            $this->vulnerabilityState($status, $plugin['version'], $scope);
            $plugin['status'] = $status;

            if ($plugin['status']['local-check']['threat'][0] !== 'safe') {
                array_push($detected, $status);
            }

            $statuses[$scope] = $status;
        }

        return $detected;
    }

    /**
     * Returns an array of strings that represent the current threat level of a given vulnerability
     * @param $status
     * @param $installedVersion
     */
    private function vulnerabilityState(&$status, $installedVersion, $scope)
    {
        $checks = [
            'needs-upgrade',
            'vulnerable',
            'abandoned'
        ];

        $key = 'local-check';
        $status[$key] = [];
        $status[$key]['threat'] = [];
        $status[$key]['update'] = [];
        $status[$key]['insecure'] = [];
        $status[$key]['abandoned'] = [];

        $installedVersionInt = $this->intVersion($installedVersion);

        foreach ($checks as $check) {
            switch ($check) {
                case 'needs-upgrade':
                    // with wordpress latest_version doesn't exist
                    // if vulnerability exists later flag for upgrade
                    if ($scope === 'wordpress') {
                        break;
                    }

                    $status[$key]['update']['now'] = ($installedVersionInt < $this->intVersion($status['latest_version']));
                    $status[$key]['update']['latest-version'] = $status['latest_version'];
                    $status[$key]['update']['installed-version'] = $installedVersion;

                    if ($status[$key]['update']['now']) {
                        array_push($status[$key]['threat'], 'needs-upgrade');
                    }

                    break;
                case 'vulnerable':
                    if (count($status['vulnerabilities']) > 0) {
                        $reverseVuln = array_reverse($status['vulnerabilities']);
                        $status[$key]['insecure']['now'] = (
                            isset($reverseVuln[0]->fixed_in) && $installedVersionInt < $this->intVersion($reverseVuln[0]->fixed_in)
                        );

                        // there is a vulnerability
                        if ($status[$key]['insecure']['now']) {
                            array_push($status[$key]['threat'], 'insecure');
                            // if is wordpress, assume upgrade needed
                            if ($scope === 'wordpress') {
                                array_push($status[$key]['threat'], 'needs-upgrade');
                            }
                        }

                        break;
                    }

                    $status[$key]['insecure']['now'] = false;
                    break;
                case 'abandoned':
                    // abandoned = 1 year since last updated
                    if (isset($status['last_updated'])) {
                        $status[$key]['abandoned']['now'] = (
                            strtotime($status['last_updated']) < strtotime("-1 year", time())
                        );

                        if ($status[$key]['abandoned']['now']) {
                            array_push($status[$key]['threat'], 'abandoned');
                        }

                        break;
                    }

                    $status[$key]['abandoned']['now'] = false;
                    break;
            }
        }

        if (empty($status[$key]['threat'])) {
            $status[$key]['threat'][] = 'safe';
        }
    }

    private function intVersion($version)
    {
        return (int)str_replace('.', '', $version);
    }

    private function notify($status)
    {
        $mailTo = get_option('moj_component_settings');
        $mailTo = $mailTo['to_email'];

        $siteName = get_option('blogname');

        // turn on html emails
        add_filter('wp_mail_content_type', function () {
            return "text/html";
        });

        $message = $this->getMailMessage($status, $siteName);

        // send a threat notification
        $subject = '[SECURITY] Issues found on ' . $siteName;
        $this->helper->setMailSubject($subject);
        $this->helper->setMailMessage($message);
        $this->helper->setMaiTo($mailTo);
        $this->helper->mail();
    }

    public function getMailMessage($data, $name)
    {
        $emailTemplate = file_get_contents(__DIR__ . '/assets/email-templates/moj-vuln-found.html');

        // list of issues
        $issuesFound = 0;
        $listOfIssues = $this->createHTMLListOfVuln($data, $issuesFound);

        $is_s = ($issuesFound > 1 ? 's' : '');
        $count = $issuesFound . ' issue' . $is_s;

        $search = [
            '{blogname}',
            '{list_of_issues}',
            '{date}',
            '{nth-issues}',
            '{require-s}'
        ];

        $replace = [
            $name,
            $listOfIssues,
            date('l jS \of F Y'),
            $count,
            'require' . (empty($is_s) ? 's' : '')
        ];

        return str_replace($search, $replace, $emailTemplate);
    }

    private function createHTMLListOfVuln($vulns, &$issuesFound)
    {
        $output = $vulnList = $list = '';
        foreach ($vulns as $vuln) {
            $isWordPress = isset($vuln['status']); // only wp has this key at this stage
            $name = ($isWordPress ? 'WordPress' : $vuln['friendly_name']);

            if (array_search('insecure', $vuln['local-check']['threat']) !== false) {
                foreach ($vuln['vulnerabilities'] as $issue) {
                    $vulnList .= $this->trtd(
                        'Vulnerability',
                        htmlspecialchars($issue->title) . '<br>Fixed in version ' . (!$issue->fixed_in ? '' : $issue->fixed_in)
                    );
                    $issuesFound++;
                }
            }

            // what's wrong?
            foreach ($vuln['local-check']['threat'] as $threat) {
                switch ($threat) {
                    case 'needs-upgrade':
                        $list .= $this->trtd(
                            'Needs Upgrading',
                            'The composer version for this software asset needs updating.'
                        );
                        $issuesFound++;
                        break;
                    case 'abandoned':
                        $list .= $this->trtd(
                            'Abandoned',
                            'Too much time has past. Please find an alternative for this plugin ASAP.'
                        );
                        $issuesFound++;
                        break;
                }
            }

            $search = ['{asset-name}', '{name}', '{vuln-list}'];

            if (!empty($vulnList)) {
                $emailTemplate = file_get_contents(
                    __DIR__ . '/assets/email-templates/moj-vuln-table.html'
                );

                $replace = [$name, 'Vulnerabilities', $vulnList];
                $output .= str_replace($search, $replace, $emailTemplate);
            }

            if (!empty($list)) {
                $emailTemplate = file_get_contents(
                    __DIR__ . '/assets/email-templates/moj-vuln-table.html'
                );

                $replace = [$name, 'Important issues', $list];
                $output .= str_replace($search, $replace, $emailTemplate);
                $list = '';
            }
        }

        return $output;
    }

    private function trtd($vuln, $description)
    {
        $code = [
            'open' => '<tr><td width="180px" class="mcnTextContent" style="padding-top:0; padding-right:18px; padding-bottom:9px; padding-left:18px;"><span style="color:#1d1d1d">',
            'mid' => '</span></span></td><td width="420px" class="mcnTextContent" style="padding-top:0; padding-right:18px; padding-bottom:9px; padding-left:18px;"><span style="color:#1d1d1d">',
            'close' => '</span></td></tr>'
        ];

        return $code['open'] . $vuln . $code['mid'] . $description . $code['close'];
    }
}
